# Default values for SDA services.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
global:

# Path where the sensitive files can be found, default is "/.secrets".
# TLS certificates or C4GH key locations can be set using global.tlsPath or global.c4ghPath respectively,
# this path will be a subpath to the secretsPath.
  secretsPath: /.secrets
  c4ghPath: "c4gh"
  tlsPath: "tls"
  jwtPath: "jwt"

# Name of an injected config file, located in the secretsPath
# If the file is located in a subpath it can be set using the confFilePath
# If no conf file is specified DB and MQ connections will be configured via ENVs
  confFile: config.yaml
  confFilePath: ""

# Deployment can be split into `external` and `internal` components
# by setting deploymentType to the desired type
# if left undefined or `all`, all services are deployed.
  deploymentType: "all"

# standalone version requires a custom schema e.g. isolated
# the files can still be overwritten in container with no change
# options are `federated` or `isolated`
  schemaType: "federated"

  ingress:
    deploy: true
    ingressClassName: "nginx"
    hostName:
      auth: ""
      doa: ""
      s3Inbox: ""
      download: ""
# If the certificates is generated by external providers
# the secrets containing them needs to be created manually.
    secretNames:
      auth: ""
      doa: ""
      download: ""
      s3Inbox: ""
# issuer requires a configured cert-manager
    issuer: ""
    clusterIssuer: ""
    # extra annotations for the ingress
    annotations: {}
    # |
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"

  log:
    level: "info"
    format: "json"

# utilize network isolation
# Make sure youâ€™ve configured a network provider with network policy support.
# There are a number of network providers that support NetworkPolicy, including:
# Calico, Cilium, Kube-router, Romana and Weave Net
  networkPolicy:
    create: false
    brokerNamespace: ""
    databaseNamespace: ""
    externalNamespace: ""
    internalNamespace: ""

## RevisionHistory
##  If defined, set the revisionHistoryLimit of the deployment, defaults to 3
##  RevisionHistoryLimit is number of old ReplicaSets to retain to allow rollback.
  # revisionHistory: 3

# Annotations applied to pods of all services.
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  podAnnotations: {}

# If an external PKI infrastructure is used set this to true
  pkiService: false
# if permissions needs to be set on the injected certificates set this to true
  pkiPermissions: true

# Assume RBAC is enabled in the cluster
  rbacEnabled: true

  podSecurityPolicy:
    create: true

# Extra security context to apply to all pods
# This should be a multi-line string mapping directly to the a map of
# the securityContext to apply to the service pods
  extraSecurityContext: {}

# If no dependency services uses TLS, postgreSQL, RabbitMQ, S3
# TLS can be globally disabled for all serives by setting enabled to false.
# Not to be used in production but handy for testing.
  tls:
    enabled: true
    issuer: ""
    clusterIssuer: ""

# If an external secrets management service is used set this to true
  vaultSecrets: false

# global configurations
  archive:
    storageType: "s3" # s3 or posix
  # The six lines below is only used with S3 backend
    s3Url: ""
    s3Bucket: ""
    s3Region: "us-east-1"
    s3ChunkSize: 15 # Chunk size in MB > 5
    s3AccessKey: null
    s3SecretKey: null
    s3CaFile: null
    s3Port: 443
  # The lines below is only used with POSIX backend
    volumePath: "/archive"
    nfsServer: ""
    nfsPath: ""

  backupArchive:
    storageType: "s3" # s3 or posix
  # The six lines below is only used with S3 backend
    s3Url: ""
    s3Bucket: ""
    s3Region: "us-east-1"
    s3ChunkSize: 15 # Chunk size in MB > 5
    s3AccessKey: null
    s3SecretKey: null
    s3Port: 443
  # The lines below is only used with POSIX backend
    volumePath: "/backup"
    nfsServer: ""
    nfsPath: ""
    copyHeader: false

  auth:
    # @param elixirID, client ID to the Elixir OIDC for the service endpoint 
    elixirID:
    # @param elixirSecret, client secret to the Elixir OIDC for the service endpoint 
    elixirSecret:
    # @param jwtSecret, name of the secret holding the jwt signing key
    jwtSecret:
    # @param jwtAlg, cipher type of the signing key
    jwtAlg: ES256
    # @param jwtKey, name of the signing key
    jwtKey:
    # @param jwtPub, name of the public signing key
    jwtPub:

  broker:
    durable: true
    exchange: ""
    host: ""
    password: ""
    port: 5671
    routingError: ""
    backupRoutingKey: ""
    ssl: true
    username: ""
    verifyPeer: true
    vhost: "/"

  cega:
    ## @param host, URI to CEGA NSS server users endpoint 
    host: ""
    ## @param user, usernamen for accessing the CEGA NSS host
    user: ""
    ## @param password, password for accessing the CEGA NSS host
    password: ""

  c4gh:
    secretName: ""
  # name of the c4gh key file.
    keyFile: ""
  # name of the public file, required for testing
    publicFile: ""
    passphrase: ""
    backupPubKey: ""

  db:
    host: ""
    name: "lega"
    passIngest: ""
    passOutgest: ""
    port: 5432
    sslMode: "verify-ca"

  doa:
    enabled: false
    outbox:
      enabled: false
      # MQ queue name for files/datasets export requests
      queue: ""
      # Outbox type can be either S3 or POSIX
      type: ""
      # Outbox location with placeholder for the username
      path: ""
      s3Url: ""
      s3Port: 443
      s3Region: ""
      s3Bucket: ""
      s3CaFile: null
      s3AccessKey: null
      s3SecretKey: null
    servicePort: 443
    envFile: env

  download:
    enabled: true
    # session key expiration time in seconds
    # default value = -1 for disabled state
    # a positive integer enables sessions
    # a negative integer disables sessions
    sessionExpiration: 28800
    # this should translate into JSON array of objects
    # with 2 keys iss and jku
    trusted:
      configPath: "iss"
      configFile: "iss.json"
      iss:
        - iss: "https://login.elixir-czech.org/oidc/"
          jku: "https://login.elixir-czech.org/oidc/jwk"

  elixir:
    oidcdHost: "https://login.elixir-czech.org/oidc/"
    jwkPath: "jwk"

  inbox:
    servicePort: 2222
    storageType: "posix"
  # These lines below are only used with posix
    path: "/inbox"
    user: "lega"
    nfsServer: ""
    nfsPath: ""
    existingClaim: ""
  # These lines below are only used with s3
    s3Url: ""
    s3Bucket: "inbox"
    s3AccessKey: null
    s3SecretKey: null
    s3ReadyPath: ""
    s3Region: ""

##################################
# service specific credentials
credentials:
  backup:
    mqUser: ""
    mqPassword: ""
    dbUser: ""
    dbPassword: ""

  doa:
    dbUser: ""
    dbPassword: ""
  
  download:
    dbUser: ""
    dbPassword: ""

  finalize:
    mqUser: ""
    mqPassword: ""
    dbUser: ""
    dbPassword: ""

  inbox:
    mqUser: ""
    mqPassword: ""

  ingest:
    mqUser: ""
    mqPassword: ""
    dbUser: ""
    dbPassword: ""

  intercept:
    mqUser: ""
    mqPassword: ""

  mapper:
    mqUser: ""
    mqPassword: ""
    dbUser: ""
    dbPassword: ""

  releasetest:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

  verify:
    mqUser: ""
    mqPassword: ""
    dbUser: ""
    dbPassword: ""

##################################
# Service specific settings

auth:
  name: auth
  replicaCount: 2
  repository: ghcr.io/neicnordic/sda-auth
  imageTag: v0.6.46
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

backup:
  name: backup
  deploy: false
  replicaCount: 1
  repository: ghcr.io/neicnordic/sda-pipeline
  imageTag: v0.3.67
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

doa:
  name: doa
  repository: ghcr.io/neicnordic/sda-doa
  imageTag: v1.6.43
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "1024Mi"
      cpu: "2000m"
  debugPort: 1234
  logpath: "/tmp/logs"
  keystorePass: "changeit"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

download:
  name: download
  replicaCount: 2
  repository: ghcr.io/neicnordic/sda-download
  imageTag: v1.6.94
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "1000m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

finalize:
  name: finalize
  replicaCount: 1
  repository: ghcr.io/neicnordic/sda-pipeline
  imageTag: v0.3.67
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

ingest:
  name: ingest
  replicaCount: 1
  repository: ghcr.io/neicnordic/sda-pipeline
  imageTag: v0.3.67
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "2000m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

intercept:
  deploy: true
  name: ingest
  replicaCount: 1
  repository: ghcr.io/neicnordic/sda-pipeline
  imageTag: v0.3.67
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

mapper:
  replicaCount: 1
  repository: ghcr.io/neicnordic/sda-pipeline
  imageTag: v0.3.67
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "2000m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

s3Inbox:
  name: s3Inbox
  repository: ghcr.io/neicnordic/sda-s3proxy
  imageTag: v0.1.124
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "1024Mi"
      cpu: "1000m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""


sftpInbox:
  name: sftpInbox
  repository: ghcr.io/neicnordic/sda-inbox-sftp
  imageTag: v1.7.63
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
  keystorePass: "changeit"
  nodeHostname: ""
# Extra annotations to attach to the pod
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""


releasetest:
  run: false
  repository: neicnordic/sda-helm-tests-support
  imageTag: latest
  imagePullPolicy: IfNotPresent
  tls:
    secretName: ""
  secrets:
    accessToken:

verify:
  replicaCount: 1
  repository: ghcr.io/neicnordic/sda-pipeline
  imageTag: v0.3.67
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "2000m"
# Extra annotations to attach to the pod
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""
